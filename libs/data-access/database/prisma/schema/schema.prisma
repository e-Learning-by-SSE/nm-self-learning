generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
  previewFeatures = ["prismaSchemaFolder"]
}

datasource db {
    provider = "postgres"
    url      = env("DATABASE_URL")
}




model UploadedAssets {
    objectName String   @id
    fileName   String
    fileType   String
    publicUrl  String
    createdAt  DateTime @default(now())
    username   String?
    user       User?    @relation(fields: [username], references: [name])

    @@index([fileName])
}



model License {
    licenseId         Int      @id @default(autoincrement())
    name              String
    url               String?
    licenseText       String?
    logoUrl           String?
    oerCompatible     Boolean  @default(false)
    // Specifies whether the license is default suggestion (only one should be true, otherwise the first one is used)
    defaultSuggestion Boolean  @default(false)
    // Specifies whether the license can be chosen by normal users or by admins only
    selectable        Boolean  @default(true)
    // Back reference required by Prisma -> Provides overview about usage
    lessons           Lesson[]
}

model SkillRepository {
  id            String        @id @default(cuid())
  name          String
  description   String?
  skills        Skill[]
  ownerName     String
  owner         User     @relation(fields: [ownerName], references: [name])

  @@unique([ownerName, name])
  @@map("skill-repositories")
}

model Skill {
    id             String          @id @default(cuid())
    name           String
    description    String?
    repositoryId   String
    repository     SkillRepository @relation(fields: [repositoryId], references: [id], onDelete: Cascade)
    children       Skill[]         @relation("parent")
    parents        Skill[]         @relation("parent")
    goalsOf        Lesson[]        @relation("providedSkills")
    requirementsOf Lesson[]        @relation("requiredSkills")

    @@unique([repositoryId, name])
    @@map("skills")
}

model EventLog {
  id          Int    @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  username    String
  resourceId  String?
  courseId    String?
  type        String
  payload     Json?
  // @@id([userId, createdAt, action]) // todo check if optimization is needed
}

// // das schema beinhaltet daten die aus dem eventlog aggregiert werden. updatedAt ist der letzte zeitpunkt an dem die daten aktualisiert wurden. 
// model EventLogAggregations {
//     id         Int    @id @default(autoincrement())
//     updatedAt DateTime @updatedAt
//     userId    String
//     videosTimeWatched Int
// }

model Notification {
  id             String   @id @default(uuid())
  component      String   // z. B. "MotdDialog", "BannerMessage"
  props          Json     // enthält die dynamischen Props der Komponente
  displayFrom    DateTime
  displayUntil   DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  targetAudience AudienceType @default(all)

  targets        NotificationUser[]
}

enum AudienceType {
  all
  user
  admin
  author
}

model NotificationUser {
  notificationId String
  userId         String 
  dismissed      Boolean  @default(false)
  seenAt         DateTime? 

  notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
user           User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@id([notificationId, userId])
}
